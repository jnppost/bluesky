stack/basecmds

"DASHEDLINE": [
            "DASHEDLINE name, lat, lon, lat, lon",
            "txt,latlon,latlon",
            lambda name, *coords: areafilter.defineArea(name, "DASHEDLINE", coords),
            "Draw a dashed line"
        ],
        "DOTTEDLINE": [
            "DOTTEDLINE name, lat, lon, lat, lon",
            "txt,latlon,latlon",
            lambda name, *coords: areafilter.defineArea(name, "DOTTEDLINE", coords),
            "Draw a dotted line"

tools/areafilter

def defineArea(areaname, areatype, coordinates, top=1e9, bottom=-1e9):
    """Define a new area"""
    if areaname == 'LIST':
        if not basic_shapes:
            return True, 'No shapes are currently defined.'
        else:
            return True, 'Currently defined shapes:\n' + \
                ', '.join(basic_shapes)
    if not coordinates:
        if areaname in basic_shapes:
            return True, str(basic_shapes[areaname])
        else:
            return False, f'Unknown shape: {areaname}'
    if areatype == 'BOX':
        basic_shapes[areaname] = Box(areaname, coordinates, top, bottom)
    elif areatype == 'CIRCLE':
        basic_shapes[areaname] = Circle(areaname, coordinates, top, bottom)
    elif areatype[:4] == 'POLY':
        basic_shapes[areaname] = Poly(areaname, coordinates, top, bottom)
    elif areatype == 'LINE':
        basic_shapes[areaname] = Line(areaname, coordinates)
    elif areatype == 'POINT':
        basic_shapes[areaname] = Point(areaname, coordinates)
    elif areatype == 'DOTTEDLINE' or areatype == 'DASHEDLINE':
        basic_shapes[areaname] = Line(areaname, coordinates)

    # Pass the shape on to the screen object
    bs.scr.objappend(areatype, areaname, coordinates)

simulation/screenio



glmap.py

class Map(glh.RenderObject, layer=-100):
    """
    Definition: Radar screen map OpenGL object.
    Methods:
        create():           Create the Objects and Buffers
        draw():             Draw the Objects
        actdata_changed():  Update buffers when a different node is selected,
                            or when the data of the current node is updated.

    Created by: Original BlueSky version
    """

    def __init__(self, parent=None):
        super().__init__(parent)

        self.map = glh.VertexArrayObject(glh.gl.GL_TRIANGLE_FAN)
        self.maptrans = glh.VertexArrayObject(glh.gl.GL_TRIANGLE_FAN)  # Transparant map
        self.coastlines = glh.VertexArrayObject(glh.gl.GL_LINES)
        self.coastindices = []
        self.vcount_coast = 0
        self.wraplon_loc = 0

        # LVNL Base Maps (for APP and ACC)
        self.basemap_lines = glh.VertexArrayObject(glh.gl.GL_LINES)
        self.basemap_dashed = glh.VertexArrayObject(glh.gl.GL_LINES, shader_type='dashed')
        self.basemap_dotted = glh.VertexArrayObject(glh.gl.GL_LINES, shader_type='dashed')
        self.basemap_points = glh.VertexArrayObject(glh.gl.GL_TRIANGLE_FAN)

        bs.net.actnodedata_changed.connect(self.actdata_changed)

    def create(self):
        """
        Function: Create the OpenGL Objects and Buffers
        Args: -
        Returns: -

        Created by: Original BlueSky version
        """

        # ---------- Base Map ----------
        lines, dashedlines, dottedlines, points = load_basemap(settings.atc_mode)

        # Lines
        self.basemap_lines.create(vertex=POLY_SIZE * 16, color=POLY_SIZE * 8)
        if lines:
            contours, colors = zip(*lines.values())
            self.basemap_lines.update(vertex=np.concatenate(contours, dtype=np.float32),
                                      color=np.concatenate(colors))
        else:
            self.basemap_lines.set_vertex_count(0)

        # Dashed lines
        self.basemap_dashed.create(vertex=POLY_SIZE * 16, color=POLY_SIZE * 8)
        if dashedlines:
            contours, colors = zip(*dashedlines.values())
            self.basemap_dashed.update(vertex=np.concatenate(contours),
                                       color=np.concatenate(colors))
        else:
            self.basemap_dashed.set_vertex_count(0)

        # Dotted lines
        self.basemap_dotted.create(vertex=POLY_SIZE * 16, color=POLY_SIZE * 8)
        if dottedlines:
            contours, colors = zip(*dottedlines.values())
            self.basemap_dotted.update(vertex=np.concatenate(contours),
                                       color=np.concatenate(colors))
        else:
            self.basemap_dotted.set_vertex_count(0)

        # Points
        point_size = settings.point_size
        num_vert = 6
        angles = np.linspace(0., 2 * np.pi, num_vert)
        x = (point_size / 2) * np.sin(angles)
        y = (point_size / 2) * np.cos(angles)
        point_vert = np.empty((num_vert, 2), dtype=np.float32)
        point_vert.T[0] = x
        point_vert.T[1] = y
        self.basemap_points.create(vertex=point_vert, color=POLY_SIZE * 8,
                                   lat=POLY_SIZE * 16, lon=POLY_SIZE * 16,
                                   instance_divisor=1)
        if points:
            contours, colors = zip(*points.values())
            self.basemap_points.update(lat=np.array(contours[::2], dtype=np.float32),
                                       lon=np.array(contours[1::2], dtype=np.float32))

        # ------- Coastlines -----------------------------
        coastvertices, self.coastindices = load_coastlines()
        self.coastlines.create(vertex=coastvertices, color=palette.coastlines)
        self.vcount_coast = len(coastvertices)

        # ---------- Map ----------
        mapvertices = np.array(
            [-90.0, 540.0, -90.0, -540.0, 90.0, -540.0, 90.0, 540.0], dtype=np.float32)
        texcoords = np.array(
            [1, 3, 1, 0, 0, 0, 0, 3], dtype=np.float32)
        self.wraplon_loc = glh.ShaderSet.get_shader(self.coastlines.shader_type).attribs['lon'].loc

        # Load and bind world texture
        max_texture_size = glh.gl.glGetIntegerv(glh.gl.GL_MAX_TEXTURE_SIZE)
        print('Maximum supported texture size: %d' % max_texture_size)
        for i in [16384, 8192, 4096]:
            if max_texture_size >= i:
                fname = path.join(settings.gfx_path,
                                  'world.%dx%d.dds' % (i, i // 2))
                fnametrans = path.join(settings.gfx_path,
                                       'transparent.%dx%d.dds' % (i, i // 2))
                print('Loading texture ' + fname)
                print('Loading texture ' + fnametrans)
                self.map.create(vertex=mapvertices,
                                texcoords=texcoords, texture=fname)
                self.maptrans.create(vertex=mapvertices,
                                     texcoords=texcoords, texture=fnametrans)
                break

    def draw(self, skipmap=False):
        """
        Function: Draw the OpenGL Objects
        Args: -
        Returns: -

        Created by: Original BlueSky version
        """

        # Send the (possibly) updated global uniforms to the buffer
        self.shaderset.set_vertex_scale_type(self.shaderset.VERTEX_IS_LATLON)

        actdata = bs.net.get_nodedata()

        # --- DRAW THE MAP AND COASTLINES ---------------------------------------------
        # Map and coastlines: don't wrap around in the shader
        self.shaderset.enable_wrap(False)

        # ---------- Base map ----------
        # Lines
        self.basemap_lines.draw()

        # Points
        self.basemap_points.draw()

        # Dashed and Dotted
        dashed_shader = glh.ShaderSet.get_shader('dashed')
        dashed_shader.bind()

        glh.gl.glUniform1f(dashed_shader.uniforms['dashSize'].loc, float(settings.interval_dashed))
        glh.gl.glUniform1f(dashed_shader.uniforms['gapSize'].loc, float(settings.interval_dashed))
        self.basemap_dashed.draw()

        glh.gl.glUniform1f(dashed_shader.uniforms['dashSize'].loc, float(settings.interval_dotted))
        glh.gl.glUniform1f(dashed_shader.uniforms['gapSize'].loc, float(settings.interval_dotted))
        self.basemap_dotted.draw()

        # ---------- Map ----------
        if not skipmap:
            if actdata.show_map:
                self.map.draw()
            else:
                self.maptrans.draw()

        # ---------- Coastlines ----------
        shaderset = glh.ShaderSet.selected
        if actdata.show_coast:
            if shaderset.data.wrapdir == 0:
                # Normal case, no wrap around
                self.coastlines.draw(
                    first_vertex=0, vertex_count=self.vcount_coast)
            else:
                self.coastlines.bind()
                shader = glh.ShaderProgram.bound_shader
                wrapindex = np.uint32(
                    self.coastindices[int(shaderset.data.wraplon) + 180])
                if shaderset.data.wrapdir == 1:
                    shader.setAttributeValue(self.wraplon_loc, 360.0)
                    self.coastlines.draw(
                        first_vertex=0, vertex_count=wrapindex)
                    shader.setAttributeValue(self.wraplon_loc, 0.0)
                    self.coastlines.draw(
                        first_vertex=wrapindex, vertex_count=self.vcount_coast - wrapindex)
                else:
                    shader.setAttributeValue(self.wraplon_loc, -360.0)
                    self.coastlines.draw(
                        first_vertex=wrapindex, vertex_count=self.vcount_coast - wrapindex)
                    shader.setAttributeValue(self.wraplon_loc, 0.0)
                    self.coastlines.draw(
                        first_vertex=0, vertex_count=wrapindex)

    def actdata_changed(self, nodeid, nodedata, changed_elems):
        """
        Function: Update buffers when a different node is selected, or when the data of the current node is updated.
        Args:
            nodeid:         ID of the Node [bytes]
            nodedata:       The Node data [class]
            changed_elems:  The changed elements [list]
        Returns: -

        Created by: Bob van Dillen
        """

        if 'ATCMODE' in changed_elems:
            self.coastlines.set_attribs(color=palette.coastlines)

            # ---------- Base Map ----------
            lines, dashedlines, dottedlines, points = load_basemap(nodedata.atcmode)

            # Lines
            if lines:
                contours, colors = zip(*lines.values())
                self.basemap_lines.update(vertex=np.concatenate(contours, dtype=np.float32),
                                          color=np.concatenate(colors))
            else:
                self.basemap_lines.set_vertex_count(0)

            # Dashed lines
            if dashedlines:
                contours, colors = zip(*dashedlines.values())
                self.basemap_dashed.update(vertex=np.concatenate(contours),
                                           color=np.concatenate(colors))
            else:
                self.basemap_dashed.set_vertex_count(0)

            # Dotted lines
            if dottedlines:
                contours, colors = zip(*dottedlines.values())
                self.basemap_dotted.update(vertex=np.concatenate(contours),
                                           color=np.concatenate(colors))
            else:
                self.basemap_dotted.set_vertex_count(0)

            # Points
            if points:
                contours, colors = zip(*points.values())
                self.basemap_points.update(lat=np.array(contours[::2], dtype=np.float32),
                                           lon=np.array(contours[1::2], dtype=np.float32))

glpoly.py

class Poly(glh.RenderObject, layer=-20):
    """
    Definition: Poly OpenGL object.
    Methods:
        create():           Create the OpenGL Objects and Buffers
        draw():             Draw the OpenGL Objects
        actdata_changed():  Update buffers when a different node is selected,
                            or when the data of the current node is updated.
        cmdline_stacked():  Check if the preview should be deactivated
        previewpoly():      Update the preview polygon

    Created by: Original BlueSky version

    Edited by: Mitchell de Keijzer
    Date: 08-04-2022
    Changed: added a new way of drawing lines and points for the maps without having to use scenario files, this way
            the maps are only loaded on the current gui
    Added:  self.maplines
            self.dottedlines
            self.dashedlines
            self.mappoints
            self.mappointslat
            self.mappointslon
    """

    def __init__(self, parent=None):
        super().__init__(parent)

        # Polygon preview object
        self.polyprev = glh.VertexArrayObject(glh.gl.GL_LINE_LOOP)

        # Fixed polygons
        self.allpolys = glh.VertexArrayObject(glh.gl.GL_LINES)
        self.alldotted = glh.VertexArrayObject(glh.gl.GL_LINES, shader_type='dashed')
        self.alldashed = glh.VertexArrayObject(glh.gl.GL_LINES, shader_type='dashed')
        self.allpfill = glh.VertexArrayObject(glh.gl.GL_TRIANGLES)
        # Points
        self.allpoints = glh.VertexArrayObject(glh.gl.GL_TRIANGLE_FAN)
        self.pointslat = glh.GLBuffer()
        self.pointslon = glh.GLBuffer()

        self.prevmousepos = (0, 0)

        bs.Signal('cmdline_stacked').connect(self.cmdline_stacked)
        bs.Signal('radarmouse').connect(self.previewpoly)
        bs.net.actnodedata_changed.connect(self.actdata_changed)

    def create(self):
        """
        Function: Create the OpenGL Objects and Buffers
        Args: -
        Returns: -

        Created by: Original BlueSky version
        """

        # --------------- Preview poly ---------------
        self.polyprev.create(vertex=POLYPREV_SIZE * 8,
                             color=palette.previewpoly, usage=glh.gl.GL_DYNAMIC_DRAW)

        # --------------- Polys ---------------
        self.allpolys.create(vertex=POLY_SIZE * 16, color=POLY_SIZE * 8)

        # --------------- Dotted lines ---------------
        self.alldotted.create(vertex=POLY_SIZE * 16, color=POLY_SIZE * 8)

        # --------------- Dashed lines ---------------
        self.alldashed.create(vertex=POLY_SIZE * 16, color=POLY_SIZE * 8)

        # --------------- Fills ---------------
        self.allpfill.create(vertex=POLY_SIZE * 24,
                             color=np.append(palette.polys, 50))

        # --------------- Points ---------------
        # OpenGL Buffers
        self.pointslat.create(POLY_SIZE * 16)
        self.pointslon.create(POLY_SIZE * 16)

        # Define vertices
        point_size = settings.point_size
        num_vert = 6
        angles = np.linspace(0., 2 * np.pi, num_vert)
        x = (point_size / 2) * np.sin(angles)
        y = (point_size / 2) * np.cos(angles)
        point_vert = np.empty((num_vert, 2), dtype=np.float32)
        point_vert.T[0] = x
        point_vert.T[1] = y

        # Define VAO
        self.allpoints.create(vertex=point_vert)
        self.allpoints.set_attribs(lat=self.pointslat, lon=self.pointslon, color=POLY_SIZE * 8,
                                   instance_divisor=1)

    def draw(self):
        """
        Function: Draw the OpenGL Objects
        Args: -
        Returns: -

        Created by: Original BlueSky version
        """

        actdata = bs.net.get_nodedata()

        # Send the (possibly) updated global uniforms to the buffer
        self.shaderset.set_vertex_scale_type(self.shaderset.VERTEX_IS_LATLON)

        # --- DRAW THE MAP AND COASTLINES ---------------------------------------------
        # Map and coastlines: don't wrap around in the shader
        self.shaderset.enable_wrap(False)

        # --- DRAW PREVIEW SHAPE (WHEN AVAILABLE) -----------------------------
        self.polyprev.draw()

        # --- DRAW CUSTOM SHAPES (WHEN AVAILABLE) -----------------------------
        if actdata.show_poly > 0 and actdata.show_maplines:
            # Polys
            self.allpolys.draw()

            # Dashed and Dotted
            dashed_shader = glh.ShaderSet.get_shader('dashed')
            dashed_shader.bind()

            glh.gl.glUniform1f(dashed_shader.uniforms['dashSize'].loc, float(settings.interval_dotted))
            glh.gl.glUniform1f(dashed_shader.uniforms['gapSize'].loc, float(settings.interval_dotted))
            self.alldotted.draw()

            glh.gl.glUniform1f(dashed_shader.uniforms['dashSize'].loc, float(settings.interval_dashed))
            glh.gl.glUniform1f(dashed_shader.uniforms['gapSize'].loc, float(settings.interval_dashed))
            self.alldashed.draw()

            # Points (set vertex is screen size)
            self.shaderset.set_vertex_scale_type(self.shaderset.VERTEX_IS_SCREEN)
            self.allpoints.draw(n_instances=len(actdata.points))

            # Draw fills
            if actdata.show_poly > 1:
                self.shaderset.set_vertex_scale_type(self.shaderset.VERTEX_IS_LATLON)
                self.allpfill.draw()

    def actdata_changed(self, nodeid, nodedata, changed_elems):
        """
        Function: Update buffers when a different node is selected, or when the data of the current node is updated.
        Args:
            nodeid:         ID of the Node [bytes]
            nodedata:       The Node data [class]
            changed_elems:  The changed elements [list]
        Returns: -

        Created by: Original BlueSky version
        """

        # Shape data change
        if 'SHAPE' in changed_elems or 'MAP' in changed_elems:
            # Make Current
            if nodedata.polys or nodedata.points or nodedata.dotted or nodedata.dashed:
                self.glsurface.makeCurrent()

            # Polys
            if nodedata.polys:
                contours, fills, colors = zip(*nodedata.polys.values())
                # Create contour buffer with color
                self.allpolys.update(vertex=np.concatenate(contours),
                                     color=np.concatenate(colors))
                # Create fill buffer
                self.allpfill.update(vertex=np.concatenate(fills))
            else:
                self.allpolys.set_vertex_count(0)
                self.allpfill.set_vertex_count(0)

            # Points
            if nodedata.points:
                # Retrieve data
                contours, fills, colors = zip(*nodedata.points.values())
                contours = np.concatenate(contours)
                # Update buffers
                self.pointslat.update(np.array(contours[::2], dtype=np.float32))
                self.pointslon.update(np.array(contours[1::2], dtype=np.float32))
                self.allpoints.update(color=np.concatenate(colors))

            # Dotted lines
            if nodedata.dotted:
                # Retrieve data
                contours, fills, colors = zip(*nodedata.dotted.values())
                contours = np.concatenate(contours)
                # Update object
                self.alldotted.update(vertex=np.array(contours, dtype=np.float32),
                                      color=np.concatenate(colors))
            else:
                self.alldotted.set_vertex_count(0)

            # Dashed lines
            if nodedata.dashed:
                # Retrieve data
                contours, fills, colors = zip(*nodedata.dashed.values())
                contours = np.concatenate(contours)

                # Update object
                self.alldashed.update(vertex=np.array(contours, dtype=np.float32),
                                      color=np.concatenate(colors))
            else:
                self.alldashed.set_vertex_count(0)

        # ATCMODE data change
        if 'ATCMODE' in changed_elems:
            self.allpfill.set_attribs(color=np.append(palette.polys, 50))
            self.polyprev.set_attribs(color=palette.previewpoly)

    def cmdline_stacked(self, cmd, args):
        """
        Function: Check if the preview should be deactivated
        Args:
            cmd:    The command [string]
            args:   The arguments [list]
        Returns: -

        Created by: Original BlueSky version
        """

        if cmd in ['AREA', 'BOX', 'POLY', 'POLYGON', 'CIRCLE', 'LINE', 'POLYLINE']:
            self.polyprev.set_vertex_count(0)

Settings.cfg


#=========================================================================
#=  Shapes default settings
#=========================================================================

# Dotted lines pixel interval
interval_dotted = 3

# Dashed lines pixel interval
interval_dashed = 5

# Points size
point_size = 4

guiclient.py

    def clear_scen_data(self):
        # Clear all scenario-specific data for sender node
        self.polys = dict()
        self.dotted = dict()
        self.dashed = dict()
        self.points = dict()
        self.custacclr = dict()
        self.custgrclr = dict()
        self.custwplbl = ''
        self.custwplat = np.array([], dtype=np.float32)
        self.custwplon = np.array([], dtype=np.float32)

        self.linemap = dict()
        self.dashmap = dict()
        self.dotmap = dict()
        self.pointmap = dict()

        # Filteralt settings
        self.filteralt = False

        # Create trail data
        self.traillat0 = []
        self.traillon0 = []
        self.traillat1 = []
        self.traillon1 = []

        # Reset transition level
        self.translvl = 4500.*ft

        # Display flags
        self.show_coast    = True
        self.show_traf     = True
        self.show_trail    = True
        self.show_pz       = False
        self.show_fir      = True
        self.show_lbl      = 2
        self.show_poly     = 1  # 0=invisible, 1=outline, 2=fill
        self.ssd_all       = False
        self.ssd_conflicts = False
        self.ssd_ownship   = set()
        self.atcmode       = settings.atc_mode.upper()
        self.show_maplines   = True
        # Display flags based on ATC mode
        self.set_atcmode(settings.atc_mode.upper())

    def siminit(self, shapes, **kwargs):
        self.__dict__.update(kwargs)
        for shape in shapes:
            self.update_poly_data(**shape)

    def panzoom(self, pan=None, zoom=None, absolute=True, screenrange=None):
        """
        Function: Pan or zoom the radar screen
        Args:
            pan:            Pan coordinates [tuple]
            zoom:           Zoom factor [float]
            absolute:       Absolute zoom switch [bool]
            screenrange:    Range of the screen [float]
        Returns: -

        Created by: Original BlueSky version
        """
        if pan:
            if absolute:
                self.pan  = list(pan)
            else:
                self.pan[0] += pan[0]
                self.pan[1] += pan[1]
        if zoom:
            self.zoom = zoom * (1.0 if absolute else self.zoom)
        if screenrange:
            self.screenrange = screenrange

    def update_color_data(self, color, acid=None, groupid=None, polyid=None):
        """
        Function: Update the color
        Args:
            color:      Color [tuple]
            acid:       Aircraft ID [str]
            groupid:    Group ID [str]
            polyid:     Polygon ID [str]
        Returns: -

        Created by: Original BlueSky version
        """

        if acid:
            self.custacclr[acid] = tuple(color)
        elif groupid:
            self.custgrclr[groupid] = tuple(color)
        else:
            # Polys
            if polyid in self.polys:
                contourbuf, fillbuf, colorbuf = self.polys.get(polyid)
                color = tuple(color) + (255,)
                colorbuf = np.array(len(contourbuf) // 2 * color, dtype=np.uint8)
                self.polys[polyid] = (contourbuf, fillbuf, colorbuf)
            # Dashed lines
            elif polyid in self.dashed:
                contourbuf, fillbuf, colorbuf = self.dashed.get(polyid)
                color = tuple(color) + (255,)
                colorbuf = np.array(len(contourbuf) // 2 * color, dtype=np.uint8)
                self.dashed[polyid] = (contourbuf, fillbuf, colorbuf)
            # Dotted lines
            elif polyid in self.dotted:
                contourbuf, fillbuf, colorbuf = self.dotted.get(polyid)
                color = tuple(color) + (255,)
                colorbuf = np.array(len(contourbuf) // 2 * color, dtype=np.uint8)
                self.dotted[polyid] = (contourbuf, fillbuf, colorbuf)
            # Points
            elif polyid in self.points:
                contourbuf, fillbuf, colorbuf = self.points.get(polyid)
                color = tuple(color) + (255,)
                colorbuf = np.array(len(contourbuf) // 2 * color, dtype=np.uint8)
                self.points[polyid] = (contourbuf, fillbuf, colorbuf)

    def update_poly_data(self, name, shape='', coordinates=None, color=None):
        """
        Function: Update the data for map lines/points
        Args:
            name        :   name of the line [str]
            shape       :   shape of the line (normal/dotted/dashed/point) [str]
            coordinates :   lat/lon coordinates [list]
            color       :   color code [tuple]
        Returns: -

        Created by: Mitchell de Keijzer
        Date: 7-4-2022
        """

        if coordinates is not None:
            # We're either updating a polygon, or deleting it. In both cases
            # we remove the current one.
            self.polys.pop(name, None)
            self.dotted.pop(name, None)
            self.dashed.pop(name, None)
            self.points.pop(name, None)

            # Break up polyline list of (lat,lon)s into separate line segments
            if shape == 'LINE' or shape[:4] == 'POLY':
                # Input data is list or array: [lat0,lon0,lat1,lon1,lat2,lon2,lat3,lon3,..]
                newdata = np.array(coordinates, dtype=np.float32)

            elif shape == 'BOX':
                # Convert box coordinates into polyline list
                # BOX: 0 = lat0, 1 = lon0, 2 = lat1, 3 = lon1 , use bounding box
                newdata = np.array([coordinates[0], coordinates[1],
                                 coordinates[0], coordinates[3],
                                 coordinates[2], coordinates[3],
                                 coordinates[2], coordinates[1]], dtype=np.float32)

            elif shape == 'CIRCLE':
                # Input data is latctr,lonctr,radius[nm]
                # Convert circle into polyline list

                # Circle parameters
                Rearth = 6371000.0             # radius of the Earth [m]
                numPoints = 72                 # number of straight line segments that make up the circrle

                # Inputs
                lat0 = coordinates[0]              # latitude of the center of the circle [deg]
                lon0 = coordinates[1]              # longitude of the center of the circle [deg]
                Rcircle = coordinates[2] * 1852.0  # radius of circle [NM]

                # Compute flat Earth correction at the center of the experiment circle
                coslatinv = 1.0 / np.cos(np.deg2rad(lat0))

                # compute the x and y coordinates of the circle
                angles    = np.linspace(0.0, 2.0 * np.pi, numPoints)   # ,endpoint=True) # [rad]

                # Calculate the circle coordinates in lat/lon degrees.
                # Use flat-earth approximation to convert from cartesian to lat/lon.
                latCircle = lat0 + np.rad2deg(Rcircle * np.sin(angles) / Rearth)  # [deg]
                lonCircle = lon0 + np.rad2deg(Rcircle * np.cos(angles) * coslatinv / Rearth)  # [deg]

                # make the data array in the format needed to plot circle
                newdata = np.empty(2 * numPoints, dtype=np.float32)  # Create empty array
                newdata[0::2] = latCircle  # Fill array lat0,lon0,lat1,lon1....
                newdata[1::2] = lonCircle

            elif shape == 'DOTTEDLINE' or shape == 'DASHEDLINE':
                newdata = np.array(coordinates, dtype=np.float32)

            elif shape == 'POINT':
                newdata = np.array(coordinates, dtype=np.float32)  # [lat, lon]

            # Create polygon contour buffer
            # Distinguish between an open and a closed contour.
            # If this is a closed contour, add the first vertex again at the end
            # and add a fill shape
            if shape == 'DOTTEDLINE' or shape == 'DASHEDLINE':
                contourbuf = np.array(newdata, dtype=np.float32)
                fillbuf = np.array([], dtype=np.float32)
            elif shape[-4:] == 'LINE':
                contourbuf = np.empty(2 * len(newdata) - 4, dtype=np.float32)
                contourbuf[0::4]   = newdata[0:-2:2]  # lat
                contourbuf[1::4]   = newdata[1:-2:2]  # lon
                contourbuf[2::4] = newdata[2::2]  # lat
                contourbuf[3::4] = newdata[3::2]  # lon
                fillbuf = np.array([], dtype=np.float32)
            elif shape == 'POINT':
                contourbuf = np.array(newdata, dtype=np.float32)
                fillbuf = np.array([], dtype=np.float32)
            else:
                contourbuf = np.empty(2 * len(newdata), dtype=np.float32)
                contourbuf[0::4]   = newdata[0::2]  # lat
                contourbuf[1::4]   = newdata[1::2]  # lon
                contourbuf[2:-2:4] = newdata[2::2]  # lat
                contourbuf[3:-3:4] = newdata[3::2]  # lon
                contourbuf[-2:]    = newdata[0:2]
                pset = PolygonSet()
                pset.addContour(newdata)
                fillbuf = np.array(pset.vbuf, dtype=np.float32)

            # Define color buffer for outline
            defclr = tuple(color or palette.polys) + (255,)
            colorbuf = np.array(len(contourbuf) // 2 * defclr, dtype=np.uint8)

            # Store new or updated polygon by name, and concatenated with the
            # other polys
            if shape == 'POINT':
                self.points[name] = (contourbuf, fillbuf, colorbuf)
            elif shape == 'DOTTEDLINE':
                self.dotted[name] = (contourbuf, fillbuf, colorbuf)
            elif shape == 'DASHEDLINE':
                self.dashed[name] = (contourbuf, fillbuf, colorbuf)
            else:
                self.polys[name] = (contourbuf, fillbuf, colorbuf)

        # If no coordinates are given, it means that the shape must be switched off by deleting the shape
        else:
            if name in self.points:
                del self.points[name]
            elif name in self.dotted:
                del self.dotted[name]
            elif name in self.dashed:
                del self.dashed[name]
            elif name in self.polys:
                del self.polys[name]